import Part, FreeCAD, math
import Draft
from FreeCAD import Base
import FreeCADGui
import math

def armaSec(identificador,diametro,separacion,recubrimiento,reclateral,ptosExtension,ladoDibSec,vectorLRefSec,hTexto):
    # Definicion de armadura bolinches
    # identificador: identificador de la armadura
    # diametro: diametro de la armadura (en unidades coherentes)
    # separacion: distancia entre ejes de barras (en unidades coherentes)
    # recubrimiento: recubrimiento (en unidades coherentes)
    # reclateral: recubrimiento minimo en los extremos para colocar la familia
    # ptosExtension: ptos. inicial y final entre los que se desarrolla la familia
    # ladoDibSec: lado hacia el cual se dara el recubrimiento (i para lado izquierdo, d para lado derecho)
    #vectorLRef: primer tramo de la linea de referencia para rotulacion de la armadura
    #hTexto: altura del texto

    vaux=ptosExtension[1].sub(ptosExtension[0])
    Laux=vaux.Length
    nesp=int((Laux-2*reclateral-diametro)/separacion)
    vaux.normalize()
    if ladoDibSec == 'i':
        vauxn=Base.Vector(-vaux.y,vaux.x)
    else:
        vauxn=Base.Vector(vaux.y,-vaux.x)
    vauxn.normalize()
    incrini=vaux.multiply((Laux-nesp*separacion)/2).add(vauxn.multiply(recubrimiento+diametro/2))
    cent=FreeCAD.Placement()
    cent.move(ptosExtension[0].add(incrini))
    ptoIniEtiq=ptosExtension[0].add(incrini)
    textoArmadura(ptoIniEtiq,vectorLRefSec,identificador,diametro,separacion,hTexto)
    vaux.normalize()
    incr=vaux.multiply(separacion)
    for i in range(0,nesp+1):
        Draft.makeCircle(diametro/2,cent,False)
        cent.move(incr)
    p1=ptoIniEtiq.add(vectorLRefSec)
    vaux.normalize()
    p2=p1.add(vaux.multiply(separacion*nesp)).sub(vectorLRefSec)
    Draft.makeWire([p1,p2])
    return

def armadura(identificador,diametro,separacion,listaPtos,listaRec,lado,radioDob,gapIni,gapFin,vectorLRef,hTexto):
    # identificador: identificador de la armadura
    # diametro: diametro de la armadura (en unidades coherentes)
    # separacion: distancia entre ejes de barras (en unidades coherentes)
    # listaPtos: lista de ptos (vectores) a partir de los cuales se genera la barra
    # listaRec: lista de recubrimientos respecto a los segmentos definidos por los puntos anteriores (en unidades coherentes)
    # lado: lado hacia el cual se dara el recubrimiento (i para lado izquierdo, d para lado derecho)
    # radioDob: radio para doblado de la armadura (en unidades coherentes)
    # gapIni: incremento (decremento si gapIni<0) de longitud de la armadura en su extremo inicial
    # gapFin: incremento (decremento si gapFin<0) de longitud de la armadura en su extremo final
    #vectorLRef: primer tramo de la linea de referencia para rotulacion de la armadura
    #hTexto: altura del texto
    
    npuntos=len(listaPtos)
    vaux=listaPtos[0].sub(listaPtos[1])
    vaux.normalize().multiply(gapIni)
    listaPtos[0]=listaPtos[0].add(vaux)
    vaux=listaPtos[npuntos-1].sub(listaPtos[npuntos-2])
    vaux.normalize().multiply(gapFin)
    listaPtos[npuntos-1]=listaPtos[npuntos-1].add(vaux)
    listaaux=[]
    for i in range (0,npuntos-1):
        vaux=listaPtos[i+1].sub(listaPtos[i])
        if lado == 'i':
            vauxn=Base.Vector(-vaux.y,vaux.x)
        else:
            vauxn=Base.Vector(vaux.y,-vaux.x)
        vauxn.normalize()
        vauxn.multiply(listaRec[i]+diametro/2)
        listaaux.append(listaPtos[i].add(vauxn))
        listaaux.append(listaPtos[i+1].add(vauxn))
                
    listaPtosArm=[listaaux[0]]
    for i in range (1,npuntos-1):
        pint=int2rectas(listaaux[2*(i-1)],listaaux[2*(i-1)+1],listaaux[2*i],listaaux[2*i+1])
        listaPtosArm.append(pint)
    
    listaPtosArm.append(listaaux[2*(npuntos-1)-1])
    # arma=Part.makePolygon(listaPtosArm)
    # armad=arma.makeFillet(radioDob,arma.Edges)
    # Part.show(armad)
    
    Draft.makeWire(listaPtosArm)
    # rotulacion
    ptoIniEtiq=listaPtosArm[int(npuntos/2)-1].add((listaPtosArm[int(npuntos/2)].sub(listaPtosArm[int(npuntos/2)-1])).multiply(0.5))
    textoArmadura(ptoIniEtiq,vectorLRef,identificador,diametro,separacion,hTexto)
    return listaPtosArm
                        
                        
def int2rectas(P1,P2,P3,P4):
    # Devuelve el punto de interseccion de 2 rectas
    # P1 y P2: ptos. que definen la 1a. recta
    # P3 y P4: ptos. que definen la 2a. recta
    if P1.x == P2.x:
        if P3.x == P4.x:
            print 'Rectas paralelas'
            Pinters=()
        else:
            xinters=P1.x
            m2=(P4.y-P3.y)/(P4.x-P3.x) #pte. de la 2a. recta
            b2=P3.y-m2*P3.x            # ordenada pto. de corte 2a. recta con eje Y
            yinters=m2*xinters+b2
            Pinters=Base.Vector(xinters,yinters)
    elif P3.x == P4.x:
        xinters=P3.x
        m1=(P2.y-P1.y)/(P2.x-P1.x) #pte. de la 2a. recta
        b1=P1.y-m1*P1.x            # ordenada pto. de corte 2a. recta con eje Y
        yinters=m1*xinters+b1
        Pinters=Base.Vector(xinters,yinters)
    else:
        m1=(P2.y-P1.y)/(P2.x-P1.x) #pte. de la 1a. recta
        b1=P1.y-m1*P1.x            # ordenada pto. de corte 1a. recta con eje Y
        m2=(P4.y-P3.y)/(P4.x-P3.x) #pte. de la 2a. recta
        b2=P3.y-m2*P3.x            # ordenada pto. de corte 2a. recta con eje Y
        if m1 == m2:
            print 'Rectas paralelas'
            Pinters=()
        else:
            xinters=(b2-b1)/(m1-m2)
            yinters=m1*xinters+b1
            Pinters=Base.Vector(xinters,yinters)
    return Pinters


def textoArmadura(ptoInic,vectorLRef,idArm,diamArm,sepArm,hTexto):
    #rotulacion de un grupo de barras de armado
    #ptoInic: pto del que arranca la linea de referencia
    #vectorLRef: primer tramo de la linea de referencia
    #idArm: identificador de la armadura
    #diamArm: diametro de la armadura
    #sepArm: separacion entre barras
    #hTexto: altura del texto
    p2=ptoInic.add(vectorLRef)
    signo=vectorLRef.x/abs(vectorLRef.x)
    p3=p2.add(Base.Vector(signo*hTexto,0))
    p4=p3.add(Base.Vector(signo*hTexto,0))
    p5=p3.add(Base.Vector(signo*hTexto/2,-hTexto/2))
    Draft.makeWire([ptoInic,p2,p3])
    if len(idArm)==1:
        pl=FreeCAD.Placement()
        pl.move(p4)
        Draft.makeCircle(hTexto*(len(idArm)+1)/2,pl,False)
    else:
        pp1=p4.add(Base.Vector(0,hTexto))
        pp2=p4.add(Base.Vector(signo*hTexto*(len(idArm)-1),hTexto))
        pp3=p4.add(Base.Vector(0,-hTexto))
        pp4=p4.add(Base.Vector(signo*hTexto*(len(idArm)-1),-hTexto))
        pp5=p4.add(Base.Vector(signo*hTexto*len(idArm),0))
        c1=Part.Arc(pp1,p3,pp3)
        c2=Part.Arc(pp2,pp5,pp4)
        l1=Part.Line(pp1,pp2)
        l2=Part.Line(pp3,pp4)
        etiq=Part.Wire([l1.toShape(),c1.toShape(),l2.toShape(),c2.toShape()])
        Part.show(etiq)
    format="%.2f"
    if vectorLRef.x > 0:
        tx=Draft.makeText(idArm + '  %%C' + str(int(1000*diamArm)) + 'c/' + str(format %sepArm) , p5)
        FreeCADGui.ActiveDocument.getObject(tx.Name).FontSize = hTexto
    else:
        tx=Draft.makeText('%%C' + str(int(1000*diamArm)) + 'c/' + str(format %sepArm) +'   ' + idArm , p5)
        FreeCADGui.ActiveDocument.getObject(tx.Name).FontSize = hTexto
        FreeCADGui.ActiveDocument.getObject(tx.Name).Justification = "Right"
    return
    
            
def monoArmadura(ptoCent,listaPtosArm,listaLong=[0.125]*10):
    # Dibuja el mono de la armadura para el despiece
    # ptoCent: punto donde colocar el punto central del mono
    # listaPtosArm: lista de ptos extremos de los segmentos que definen la armadura
    # listaLong: lista con las longitudes de los segmentos del mono (normalmente se tomara el valor por defecto)
    npuntos=len(listaPtosArm)
    lTotal=0
    lSegm=[]
    ptosMono=[Base.Vector(0,0)]
    xptosMono=[0]
    yptosMono=[0]
    posTextosMono=[]
    for i in range (0,npuntos-1):
        vaux=listaPtosArm[i+1].sub(listaPtosArm[i])
        lSegm.append(vaux.Length)
        lTotal=lTotal+lSegm[i]
        paux=ptosMono[i].add(vaux.normalize().multiply(listaLong[i]))
        ptosMono.append(paux)
        xptosMono.append(paux.x)
        yptosMono.append(paux.y)
        paux2=ptosMono[i].add(vaux.normalize().multiply(listaLong[i]/2))
        posTextosMono.append(paux2)
    xmin=min(xptosMono)
    xmax=max(xptosMono)
    ymin=min(yptosMono)
    ymax=max(yptosMono)
    vtrasl=ptoCent.sub(Base.Vector((xmin+xmax)/2,(ymin+ymax)/2))
    for i in range (0,npuntos):
        ptosMono[i]+=vtrasl
    Draft.makeWire(ptosMono)
    format="%.2f"
    for i in range (0,npuntos-1):
        tx=Draft.makeText(str(format %lSegm[i]),posTextosMono[i].add(vtrasl))
        ang=(ptosMono[i+1].sub(ptosMono[i])).getAngle(Base.Vector(1,0))
        FreeCADGui.ActiveDocument.getObject(tx.Name).FontSize = 0.025
        FreeCADGui.ActiveDocument.getObject(tx.Name).Justification = "Center"
        FreeCADGui.ActiveDocument.getObject(tx.Name).Rotation = ang*180/math.pi
    return 

def cuadroDespiece(anchoColumnas,hFilas,hTexto,familiasArmad):
    # Cuadro de despiece de la armadura
    # anchoColumnas: ancho de las columnas de cuadro de despiece (corresponden a posici'on, esquema, diam. y separac., No. de barras y longitud de cada barra)
    # hFilas: altura de las filas
    # hTexto: altura textos
    # familiasArmad: datos de las armaduras
    anchoTotal=0
    for i in anchoColumnas:
        anchoTotal +=i

    Draft.makeRectangle(anchoTotal,hFilas*(len(familiasArmad)+1))
    p1=Base.Vector(0,0)
    p2=p1.add(Base.Vector(0,hFilas*(len(familiasArmad)+1)))
    for i in range (0,len(anchoColumnas)):
        p1=p1.add(Base.Vector(anchoColumnas[i],0))
        p2=p2.add(Base.Vector(anchoColumnas[i],0))
        Draft.makeLine(p1,p2)

    p1=Base.Vector(0,hFilas*(len(familiasArmad)))
    p2=p1.add(Base.Vector(anchoTotal,0))
    Draft.makeLine(p1,p2)

    #T'itulos para la tabla de despiece
    titulosTabla=['POS.','ESQUEMA','%%C/SEP.','NUM.','LONGITUD']
    pTexto=p1.add(Base.Vector(hTexto/2,hFilas/2-hTexto/2))
    for i in range[0,len(titulosTabla)]:
        tx=Draft.makeText(titulosTabla[i],pTexto)
        pTexto=pTexto.add(Base.Vector(anchoColumnas[i]))
        FreeCADGui.ActiveDocument.getObject(tx.Name).FontSize = hTexto
